// prisma/schema.prisma
// Base: your SaaS template with NextAuth + Stripe elsewhere
// Added: Company fields on User, Employee, ActivitySpan
// Added: SeqPatternLifetime (per-employee) and SeqPatternCompany (company-wide aggregation)

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// -------------------- NextAuth core (unchanged) -------------------- 

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// -------------------- Company = auth User -------------------- 

model User {
  id                    String    @id @default(cuid())
  name                  String
  email                 String    @unique
  emailVerified         DateTime?
  image                 String?
  password              String?
  passwordResetToken    String?   @unique
  passwordResetTokenExp DateTime?

  // Company (tenant) fields
  slug            String    @unique // company slug, set after signup
  userLimit       Int       @default(0) // number of employees allowed
  subscriptionEnd DateTime? // null means active or handled by Stripe webhooks

  // Relations
  accounts  Account[]
  sessions  Session[]
  employees Employee[]

  // Data
  ActivitySpan       ActivitySpan[]
  SeqPatternLifetime SeqPatternLifetime[]
  SeqPatternCompany  SeqPatternCompany[] // NEW: company-wide aggregates
  PatternCursor      PatternCursor[]
  BillingRecord      BillingRecord[]
}

// -------------------- Employees (agent users) -------------------- 

model Employee {
  id        String  @id @default(cuid())
  companyId String
  name      String
  email     String? @unique

  // Agent auth/binding
  token         String    @unique // used by Electron; generated server-side
  tokenActive   Boolean   @default(true)
  boundDeviceId String? // first device that registers with this token
  lastUsed      DateTime?
  createdAt     DateTime  @default(now())

  // Relations
  company User @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // Data
  spans         ActivitySpan[]
  patternsLife  SeqPatternLifetime[]
  PatternCursor PatternCursor[]

  @@index([companyId])
}

// -------------------- Agent upload: events -------------------- 

model ActivitySpan {
  id         String @id @default(cuid())
  companyId  String
  employeeId String

  // With eager logging we store just the focused app at a timestamp.
  app       String
  createdAt DateTime @default(now())

  company  User     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([companyId, app])
  @@index([companyId, employeeId, createdAt])
}

// -------------------- Patterns: per-employee lifetime --------------------

model SeqPatternLifetime {
  id         String   @id @default(cuid())
  companyId  String
  employeeId String
  n          Int
  seqKey     String
  support    Int      @default(0) // cumulative across all time for this employee
  firstSeen  DateTime @default(now())
  lastSeen   DateTime @default(now())

  company  User     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([companyId, employeeId, n, seqKey])
  @@index([companyId, n, support])
}

// -------------------- Patterns: company-wide aggregation (NEW) --------------------

model SeqPatternCompany {
  id        String   @id @default(cuid())
  companyId String
  n         Int
  seqKey    String
  support   Int      @default(0) // total count across all employees
  employees Int      @default(0) // distinct employees who exhibited it
  firstSeen DateTime @default(now())
  lastSeen  DateTime @default(now())

  company User @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, n, seqKey])
  @@index([companyId, support])
  @@index([companyId, employees])
}

model PatternCursor {
  companyId     String
  employeeId    String
  lastCreatedAt DateTime? // last processed ActivitySpan.createdAt
  tail          Json? // JSON array of last (nMax-1) apps from the *collapsed* stream
  updatedAt     DateTime  @updatedAt

  company  User     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@id([companyId, employeeId])
  @@index([companyId, employeeId])
}

model BillingRecord {
  id              String   @id @default(cuid())
  companyId       String
  stripeSessionId String   @unique
  planId          String // "basic" | "pro" | "business"
  seats           Int
  amountCents     Int
  paidAt          DateTime // when we confirm the session is paid
  createdAt       DateTime @default(now())

  company User @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, paidAt])
}
